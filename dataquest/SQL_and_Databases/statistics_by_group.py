#!/usr/bin/env python
"""
In many cases, we want to drill down and compute summary statistics per-group. In this mission, we'll
explore how to calculate more granular summary statistics. We'll switch back to writing SQL queries
directly instead of using Python so we can focus more on the SQL syntax.

We'll be working with a dataset on jobs that's stored in the recent_grads table of jobs.db. Each row
represents a single college major, and contains information about post-graduation employment of
students who had the major. You can find out more about the dataset here. Here are descriptions of a
few of the columns (the whole dataset has 21 columns):
    * Rank - The numerical rank of the major by post-graduation median earnings
    * Major_code - The numerical code of the major
    * Major - The description of the major
    * Major_category - The category of the major
    * Total - The total number of people who studied the major
    * Men - The number of men who studied the major
    * Women - The number of women who studied the major
    * ShareWomen - The share of women (from 0 to 1) who studied the major
    * Employed - The number of people who studied the major and were employed post-graduation

As we go through this mission, we'll drill down and compute summary statistics by group, and answer questions like:
    - What's the share of women in each major category?
    - What major categories are the most likely to be employed post-graduation?
    - What percentage of people in each major category get a low wage job?

We cover the GROUP BY and HAVING statements. With these statements, we can calculate powerful
summary statistics in SQL quickly.
"""
import sqlite3

conn = sqlite3.connect("../data/jobs.db")
cur = conn.cursor()

# Write a SQL query that displays all of the columns and the first 5 rows of the recent_grads table
query = 'SELECT * FROM recent_grads LIMIT 5;'
first5 = cur.execute(query).fetchall()
print("Data from first 5 rows of jobs database:\n{}".format(first5))


## The GROUP BY Statement
# The GROUP BY SQL statement allows us to compute summary statistics for each group in a dataset.
# Groups are defined by the unique values in a column or set of columns. The unique values are
# equivalent to using the DISTINCT statement. To illustrate, we can figure out the total number of
# people employed in each major category with the following query:
#   SELECT Major_category, SUM(Employed) FROM recent_grads GROUP BY Major_category;
query = 'SELECT Major_category, AVG(ShareWomen) FROM recent_grads GROUP BY Major_category;'
women_by_category = cur.execute(query).fetchall()
print("Data for share of women by Major Category:\n{}".format(women_by_category))


## The AS Statement
# You may have noticed that in the last screen, specifying AVG(ShareWomen) caused the column to show
# up with that name in the results. This can often be unintuitive, and make it hard to work with the
# results of SQL queries. In order to help with this, when we select columns, we can rename them
# using the AS statement. Here's an example:
#   SELECT AVG(ShareWomen) AS average_female_share FROM recent_grads;
query = 'SELECT SUM(Men) AS total_men, SUM(Women) AS total_women FROM recent_grads;'
total_by_gender = cur.execute(query).fetchall()
print("Total Men and Women:  {}".format(total_by_gender))

# Find the percentage of graduates that are employed in each major category.
query = 'SELECT Major_category, AVG(Employed) / AVG(Total) as share_employed FROM recent_grads GROUP BY Major_category;'
employed_by_category = cur.execute(query).fetchall()
print("Percentage of graduates that are employed in each major category\n{}".format(employed_by_category))


## The HAVING Statement
# Sometimes, we'll want to select a subset of rows after we perform a GROUP BY query. For instance,
# in the last screen, we may have only wanted to select rows where share_employed is greater than
# .8. We can't use the WHERE clause to do this, because share_employed isn't a column in
# recent_grads. Instead, it's a virtual column that's generated by the GROUP BY statement.
#
# In cases like this, where we want to filter on a generated column, we can use the HAVING statement.
# Here's an example:
#   SELECT Major_category, AVG(Employed) / AVG(Total) AS share_employed
#   FROM recent_grads
#   GROUP BY Major_category
#   HAVING share_employed > .8;
# Note how we're able to use the same column name in the HAVING statement that we specified using
# the AS statement. SQL allows us to use custom column names in subsequent statements, including HAVING.

# Find all the major categories where the share of graduates with low wage jobs is greater the .1.
query = '''SELECT Major_category, AVG(Low_wage_jobs) / AVG(Total) as share_low_wage
           FROM recent_grads
           GROUP BY Major_category
           HAVING share_low_wage > 0.1'''
low_wages = cur.execute(query).fetchall()
print("Major categories where the share of graduates with low wage jobs is greater than 10%:")
print(low_wages)


## The ROUND Function
# In the above example, the percentages we got as results were very long and hard to read -- they
# looked like 0.16833085991095678. We can use the SQL ROUND function to round values when we query them.
#   SELECT Major_category, ROUND(ShareWomen, 2) AS rounded_share_women FROM recent_grads;
# The above SQL query will round the ShareWomen column to 2 decimal places, and display the results.

# Write a query that returns the share of women per major catgegory, but rounds it to 4 decimal places
query = 'SELECT Major_category, ROUND(ShareWomen, 4) FROM recent_grads GROUP BY Major_category LIMIT 10;'
rounded_women = cur.execute(query).fetchall()
print("Share of women per Major category, rounded to 4 decimal places:\n{}".format(rounded_women))


## Nested Functions
# We can nest SQL functions, such as rounding a mathematcal expression
query = '''SELECT Major_category, ROUND(AVG(College_jobs) / AVG(Total), 3) as share_degree_jobs
           FROM recent_grads
           GROUP BY Major_category
           HAVING share_degree_jobs < 0.3;'''
low_degree = cur.execute(query).fetchall()
print("Major categories with a low share of degreed jobs:\n{}".format(low_degree))
